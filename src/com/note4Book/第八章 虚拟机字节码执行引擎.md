## 虚拟机字节码执行引擎  

- 分类:  

    - 解释执行:通过解释器执行    
    - 编译执行:通过即时编译器产生本地代码执行  
    PS:可以同时存在,并不冲突.而且同时存在是主流方式.  
    
### 运行时栈帧  

- 基本执行单元:方法  
- 存储:方法局部变量表,操作数栈,动态连接,方法返回地址  
- 每个方法都有它自己的栈帧,栈帧的入栈和出栈的过程,伴随着方法的开始执行和执行结束
- 大小在编译期都已经被计算|固定下来,不会在运行时进行大小的扩充或缩减  
- 当前栈帧:方法调用链很长的时候会有很多栈帧被压在栈中,位于栈顶的栈帧才是生效的,同样栈顶栈帧对应的方法是正在执行的方法,又被称作"当前栈帧"  

#### 局部变量表:
- 顾名思义就是存放方法参数和局部变量,在编译期就会固定在class文件中的Code属性中,使用max_locals数据项确定该方法所分配的局部变量
表的最大容量
- 最小单位:变量槽  
- 一个变量槽需要能存放下一个boolean,byte,char,short,int,float,reference,returnAddress(不包括double和long,
这意味着它可以占用两个或更多变量槽),这些变量最少是需要32位空间去存储  
- returnAddress已不常用,初始是为jsr,jsr_w和ret服务,来做异常时的处理,但是现在已经全部改为异常表处理  
    
#### 操作数栈  

- 存放操作数的空间,可以存放包括long和double在内的任意Java类型,比如要计算1+3,1和3是被压在操作数栈顶,使用iadd指令取栈顶的两个数1,3,
计算出结果4后,重新压入操作数栈中
- 同样的操作数栈的深度也是在编译成class文件时就可以确定的  

#### 动态连接  

-   

#### 方法返回地址  

- 用来保存一个方法执行完成后,主调方法的状态.
- 一个方法开始执行之后,只有两种途径可以退出这个方法:
    1. 正常调用完成: 执行到任何返回的字节码指令,这种方法可以带执行结果当然也可以不带 
    2. 异常调用完成: 出现任何异常,且方法内没有办法妥善处理,这种退出形式不会携带任何返回值

### 方法调用  

#### 解析调用  

- 在调用静态方法,私有方法,实例构造器(构造方法),父类方法,final修饰的方法时执行invokestatic,invokespecial字节码指令(除final修饰的
方法,其使用invokevirtual指令),这个过程被称为解析调用  
- 解析调用一定是静态的,在编译期间就完全确定,在类加载时就可以把符号引用解析为该方法的直接引用  

#### 分派  

- 静态类型:等号左边的类型  
- 运行时类型|实际类型:new后边的类型
- 方法重载是在编译时确定的,方法的重载是根据对象的静态类型来判断.依赖静态分派.
- 类的重写是在程序运行时才确定的,具体执行方法时根据对象的实际类型来判断.依赖动态分派.

### 动态类型语言支持  

- invokeDynamic  

### 基于栈的字节码解释执行引擎  

- 在大部分处理器硬件上都是使用基于寄存器的执行引擎,基于栈永远都是通过操作指令操作栈顶的一个或数个数据来完成执行
