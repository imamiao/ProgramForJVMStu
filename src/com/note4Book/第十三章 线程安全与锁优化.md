线程安全  

- 不可变  

    - 不可变性能直接保证线程安全(除非this引用逃逸)  
    - 对于基本数据类型在定义时使用final修饰就能直接构造出一个不可变的对象;对于对象类型,需要在内部保证其内部属性不会再被修改,比如
    把对象内部的每一个基本类型数据在定义时都设置成final,一旦这个这个对象被构造出来那么这个对象同样是不可变的.  
    
- 绝对线程安全  

    - 能完全满足BG给出的线程安全的定义,但是定义非常严格,实现出来非常困难.
    - 目前JavaApi库中绝大部分的标明线程安全的容器例如Vector,HashTable等都不满足绝对线程安全  
    
- 相对线程安全  

    - 通常意义上讲的线程安全,保证对这个对象单次的操作是线程安全的,我们在调用的时候不需要额外的保证措施,但是对于一些特殊特定顺序的调用
    并不能保证调用的正确性.
    - 标明线程安全的容器例如Vector,HashTable,Collections等都是这个层级的线程安全

- 线程兼容  

    - 本身不是线程安全的但是通过合适的同步手段可以实现线程安全，Java类库中的大部分类都是线程兼容的，例如ArrayList，HashMap..
    
- 线程对立  

    - 多线程的死对头，不管怎么去同步，都无法在多线程环境中并发使用代码  
    
线程安全的实现方法  

- 互斥同步（悲观锁）  

    - 在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程（或者一些，使用信号量）使用。
    - 可使用临界区，互斥量，信号量方式实现  
    - 举例：
    
        - synchronized关键字：重量级锁  
        - ReentrantLock（重入锁）：等待可中断，可实现公平锁，可以绑定多个条件
    
- 非阻塞同步（乐观锁）  

    - 需要硬件支持，基于冲突检测的乐观并发策略  
    - 实例：测试并设置（Test and Set），加载并交换（Compare and Swap，CAS）  
        
        - CAS：在AtomicInteger类中的campareAndSet（）和getAndIncrement（）等方法使用CAS实现
        - CAS存在ABA问题，即如果一个值原始值为A被修改为B后又被修改为A，那么使用CAS是不会被发现的  
        
- 无同步方案  

    - 如果不涉及共享数据那么无需同步即可保证线程安全，天生就是线程安全的  
    
        - 可重入代码：在任何时候中断它，在任意操作之后继续执行它仍能获得正确结果。特征：不依赖全局变量、存储在对上的数据和公用的
        系统资源，用带的状态量都由参数中传入，不调用非可重入方法。（感觉大部分工具类方法都符合？）   
        - 线程本地存储：保证该变量只在一个线程内可见。使用ThreadLocal类来实现线程本地存储的功能，
        每一个线程都有一个ThreadLocalMap<ThreadLocalHashCode,Obj>,每一个ThreadLocal对象都有一个ThreadLocalHashCode，
        通过它就在ThreadLocalMap中找到值  
        
锁优化  

- 自旋锁和自适应自旋  

    - 让线程执行一个忙循环（自旋），从而不放弃处理器的执行时间，稍微等一下持有锁的线程。  
    - 1.4+，默认关闭，使用-XX：+UseSpinning开启；1.6+，默认开启。
    - 默认自旋次数为10，可使用-XX：PreBlockSpin来更改  
    - 自适应自旋，也就是更智能的自旋。会自行判断自旋的收益，需要多自旋一会儿的就多自旋一会儿；自旋收益小的，直接让线程放弃自旋，让出处理器  

- 锁消除  

    - 基于逃逸分析，如果一段代码不存在数据共享，就会消除掉锁。  
    - 很多同步操作不是程序员手动实现的而是Java自动优化加上的  
    
- 锁粗化  

    - 在适当的情况下把锁的锁定范围扩大，以减少执行锁定的次数  
    
- 轻量级锁  

    - 1.6+新加入的锁机制，轻量级不使用操作系统互斥量。
    - 基于"对于绝大部分的锁，在整个同步周期内都是不存在竞争的"这一经验法则，使用CAS来完成加锁｜解锁，从而避开了使用互斥量的开销；如果有竞争不仅有CAS的开销
    还会使用锁膨胀，重新使用互斥量，造成两方面的性能浪费  

- 偏向锁  

    - 偏向锁在无竞争的情况下把整个同步消除，省去了轻量级锁CAS操作的开销。比轻量级锁更进一步  
    - 这个锁会偏向于第一个获得它的线程，如果接下来的执行过程中，该锁一直没有被其他线程获取，那么持有偏向锁的线程将永远不需要同步。  
    - 1.先进偏向模式  2.执行过程中如果有其他线程尝试获取它，则取消偏向模式 3.如果没有其他线程获取它，保持偏向；该线程下一次获取它的时候，省略同步过程，直接锁定  
    - 如果该对象被要求重算hashcode，那么该对象将变得不可偏向，并执行锁膨胀，转换为重量级锁