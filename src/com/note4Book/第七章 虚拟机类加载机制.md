### 类加载过程  
![JVM内存区域](../../../resource/截屏2020-04-15上午9.40.51.png)    

### 初始化  

#### 有且只有以下6种情况（主动引用）必须立即对类进行'初始化'  

1. 遇到new，getstatic，putstatic，invokestatic这四条字节码指令  
    
    - 使用new关键字实例化对象  
    - 读取或设置一个static字段（除被final修饰的字段，因为它在编译时结果已经放到常量池中）  
    - 调用一个静态方法  
    
2. 使用java.lang.reflect包的方法对类进行反射，且还没有初始化过  
3. 在初始化一个类时，如果发现其父类还没有初始化，那么就需要先初始化其父类（对于接口有些许区别，在一个接口初始化时，并不要求
父接口全部初始化，只有在真正使用到父接口时<如引用接口中定义的常量>才会初始化     
4. JVM启动时会初始化包含main()方法的类  
5. 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为
REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且
这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。  
6. jdk1.8+中使用接口中的默认方法（即被default修饰的接口方法），如果有这个接口的实现类发生了初始化，那该
接口要在其之前被初始化  

#### 典型不会触发初始化的被动引用  

1. 子类调用父类的静态属性，不会触发子类初始化（只会触发父类初始化）  
2. 定义一个类型数组，例如 `Person[] p = new Person[]` 并不会真正初始化Person类  
3. 调用一个类中被final修饰的常量，因为在编译时被写入常量池，常量化使用，所以不会初始化定义它的类  

### 加载  

1. 通过一个类的全限定名获取定义此类的二进制字节流  
2. 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构  
3. 在内存中生成一个代表这个累的java.lang.Class对象，作为方法区这个类的各种数据的访问入口  

### 连接  

#### 验证 

验证Class文件的字节流中包含的信息符合规范要求

- 文件格式验证：包括0xCAFEBABE开头，class文件和jvm版本匹配，常量池中常量类型检查....  
- 元数据验证：是否有父类，是否实现了父类或接口中的所有要求实现的方法，是否继承了不允许被继承的类...
- 字节码验证：主要是验证类的方法体（Code属性），保证被校验类的方法在运行时不会作出危害虚拟机安全的行为  
- 符号引用验证：主要就是验证该类是否缺少或者被禁止访问它依赖的某些外部类，方法，字段等资源，例如通过类的名字能否找到对应
的类，符号引用中类，字段，方法的可访问性是否被当前类访问...  

#### 准备  

为静态变量（被static修饰的变量）分配内存空间并设置**初始值**。1.7-分配在方法区中，1.8+分配在堆内存中。  
也就是过了这个阶段静态变量的值一般会被设置为此类型的初始值0，0L，false，null等。二般情况：如果静态对象同时还被final修饰，那么
在这个阶段是会被赋予用户设置的值。  

#### 解析  

把常量池内的符号引用替换为直接引用的过程  

- 符号引用：用一组符号来描述所引用的目标，有JVM无关性，只要能无歧义的定位到目标即可。引用的目标不一定是已经加载到JVM内存
中的内容。  
- 直接引用：直接指向目标的指针，相对偏移量或间接指针。和JVM直接相关，存在直接引用那么目标一定在JVM内存中已经存在  

  