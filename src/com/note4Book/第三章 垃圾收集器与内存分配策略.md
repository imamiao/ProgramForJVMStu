#### 垃圾对象标记算法  

1. 引用计数算法  
    
    - 优点:原理简单,判定效率高  
    - 缺点:需要额外的空间来存储引用计数器,如果对象数量庞大,占用空间会比较可观;很难解决循环引用的问题

2. 可达性分析算法  

    - 判断与GCRoots的连通性,如果不联通(可达),被判定为可回收对象
    - 即使判定为可回收对象,也不是一定会被回收:需要两次标记,
    第一次标记即对象不可达,第二次标记即没有覆盖finalize()方法或finalize()方法已经执行过了.(后事已经交代过了,可以安心放手了😂😂)
    经过这两次标记才会在下一次GC时被回收.
    - 如果覆盖了finalize()且还没有被执行过(需要交代后事,且还没有交代),对方放入一个队列中,等待虚拟机调用它的finalize()方法(只是会调用,不保证能执行完).
    - 在finalize()方法中重新使自己变得可达,那么它就能逃过一劫.
    - **finalize()方法不建议使用**,不要用它做任何的事情.因为不保证会执行成功.

#### 对方法区进行回收  

- 主要回收对象:废弃的常量 和 不再使用的类型(类型卸载)
- 回收效率不高
- 类型卸载要求苛刻

#### GC算法  

1. 标记-清除算法  

    - 分为标记,清除两部分,'逐渐'标记,统一清除.  
    - 作为其他GC算法的基础.  
    - 缺点:  
        
        - 执行效率不稳定,执行效率随对象数量增长而降低  
        - 空间碎片化  

2. 标记-复制算法  

    - 存在两个一摸一样大小的区域（from区，to区），每次只使用其中一个区域，如果当前使用的区域
    空间满了，触发GC，把存活下来的对象，复制到另一个未使用的区域，清空当前区域。
    - 优点：不会产生碎片，实现简单  
    - 缺点：空间浪费多
    - Hotspot VM在新生代的回收算法："Appel式回收"  
    
        - 新生代划分为：一块较大的Eden空间和两块较小的Survivor空间。
        - Eden空间和其中一个Survivor空间中存活的对象复制到另一块Survivor空间中，
        然后清空Eden和使用过的Survivor空间。
        
3. 标记-整理算法  

    - 在标记清除算法上加上内存整理的一步，来避免内存碎片。
    - 在整理的时候会出现"stop the world"的情况，所以又被称为重GC。