#### 垃圾对象标记算法  

1. 引用计数算法  
    
    - 优点:原理简单,判定效率高  
    - 缺点:需要额外的空间来存储引用计数器,如果对象数量庞大,占用空间会比较可观;很难解决循环引用的问题

2. 可达性分析算法  

    - 判断与GCRoots的连通性,如果不联通(可达),被判定为可回收对象
    - 即使判定为可回收对象,也不是一定会被回收:需要两次标记,
    第一次标记即对象不可达,第二次标记即没有覆盖finalize()方法或finalize()方法已经执行过了.(后事已经交代过了,可以安心放手了😂😂)
    经过这两次标记才会在下一次GC时被回收.
    - 如果覆盖了finalize()且还没有被执行过(需要交代后事,且还没有交代),对方放入一个队列中,等待虚拟机调用它的finalize()方法(只是会调用,不保证能执行完).
    - 在finalize()方法中重新使自己变得可达,那么它就能逃过一劫.
    - **finalize()方法不建议使用**,不要用它做任何的事情.因为不保证会执行成功.

#### 对方法区进行回收  

- 主要回收对象:废弃的常量 和 不再使用的类型(类型卸载)
- 回收效率不高
- 类型卸载要求苛刻

#### GC算法  

1. 标记-清除算法  

    - 分为标记,清除两部分,'逐渐'标记,统一清除.  
    - 作为其他GC算法的基础.  
    - 缺点:  
        
        - 执行效率不稳定,执行效率随对象数量增长而降低  
        - 空间碎片化  

2. 标记-复制算法  

    - 

