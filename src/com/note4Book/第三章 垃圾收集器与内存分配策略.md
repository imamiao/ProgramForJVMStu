#### 垃圾对象标记算法  

1. 引用计数算法  
    
    - 优点:原理简单,判定效率高  
    - 缺点:需要额外的空间来存储引用计数器,如果对象数量庞大,占用空间会比较可观;很难解决循环引用的问题

2. 可达性分析算法  

    - 判断与GCRoots的连通性,如果不联通(可达),被判定为可回收对象
    - 即使判定为可回收对象,也不是一定会被回收:需要两次标记,
    第一次标记即对象不可达,第二次标记即没有覆盖finalize()方法或finalize()方法已经执行过了.(后事已经交代过了,可以安心放手了😂😂)
    经过这两次标记才会在下一次GC时被回收.
    - 如果覆盖了finalize()且还没有被执行过(需要交代后事,且还没有交代),对方放入一个队列中,等待虚拟机调用它的finalize()方法(只是会调用,不保证能执行完).
    - 在finalize()方法中重新使自己变得可达,那么它就能逃过一劫.
    - **finalize()方法不建议使用**,不要用它做任何的事情.因为不保证会执行成功.

#### 对方法区进行回收  

- 主要回收对象:废弃的常量 和 不再使用的类型(类型卸载)
- 回收效率不高
- 类型卸载要求苛刻

#### GC算法  

1. 标记-清除算法  

    - 分为标记,清除两部分,'逐渐'标记,统一清除.  
    - 作为其他GC算法的基础.  
    - 缺点:  
        
        - 执行效率不稳定,执行效率随对象数量增长而降低  
        - 空间碎片化  

2. 标记-复制算法  

    - 存在两个一摸一样大小的区域（from区，to区），每次只使用其中一个区域，如果当前使用的区域
    空间满了，触发GC，把存活下来的对象，复制到另一个未使用的区域，清空当前区域。
    - 优点：不会产生碎片，实现简单  
    - 缺点：空间浪费多
    - Hotspot VM在新生代的回收算法："Appel式回收"  
    
        - 新生代划分为：一块较大的Eden空间和两块较小的Survivor空间。
        - Eden空间和其中一个Survivor空间中存活的对象复制到另一块Survivor空间中，
        然后清空Eden和使用过的Survivor空间。
        
3. 标记-整理算法  

    - 在标记清除算法上加上内存整理的一步，来避免内存碎片。
    - 在整理的时候会出现"stop the world"的情况，所以又被称为重GC。
    
#### 跨代引用  

- 在新生代中建立一个名为记忆集的数据结构:记录从非收集区域指向收集区域的指针集合,以解决跨代引用的问题;进一步是为了缩减GC Roots扫描范围  
- 记忆集是一个抽象概念,按记录精度可划分为:字长精度,对象精度,卡精度  
- 卡精度,的具体实现被称为卡表,最常使用  

#### 写屏障  

- 对 '引用类型赋值操作' 的切面,所以在赋值前后都可以执行额外的动作.  
- 写屏蔽可分为写前屏蔽和写后屏蔽  
- 大部分收集器都用到了写后屏蔽,G1收集器用到了前后屏蔽  

#### 并发可达性  

- 在通过GC Roots 对引用链进行扫描时,用户程序并发修改其中一些引用关系导致的错误  
- 解决方法:  
    
    1. 增量更新(CMS)  
    2. 原始快照(G1,Shenandoah)

#### G1(Garbage First)收集器  

- 里程碑式的收集器  
- 特点:  

    - 依旧是保留新生代和老年代的概念,但是和以往的其他分代收集器思路很不同  
    - G1可以由用户指定期望的停顿时间
    - G1不再有固定大小和比例的分代空间,而是把整个堆等分成很多相同大小的独立区域(Region),
    每个Region不再有固定的分区,可以根据需要扮演Eden空间,Survivor空间或老年代空间  
    - G1收集器不再固定的对新生代或老年代空间进行统一收集,转变为针对单个或多个Region进行收集,又被称为(Mixed GC)  
    - 过程:初始标记(STW),并发标记,最终标记(STW),筛选回收(STW)


#### Shenandoah收集器(Beat)  

- 由Redhat公司独立发展,在OpenJDK中但是不在OracleJDK中  
- 特点:  

    - "全阶段"并行,低延迟  
    - 抛弃记忆集,采用连接矩阵来处理跨Region引用  
    - 过程: 初始标记(STW),并发标记,最终标记(MinSTW),并发清理(如果某个Region中一个存活的对象都没有,触发这一步),并发回收(先复制,后回收),
    初始引用更新(修正引用MinSTW),并发引用更新,最终引用更新(STW),并发清理  
    - 转发指针(Brooks Pointer):用来解决对象移动和并发访问的问题.在对象结构前加一个引用字段,如果没有发生移动那么就指向自己,如果发生发生移动,
    就指向新位置
    
#### ZGC收集器(Beat) 

- Oracle研发,并入JDK11  
- 特点:  

    - 不再进行分代收集
    - Region: 有动态性,动态创建和销毁.容量不等,按大小分为三种:2MB, <256KB;32MB, [256KB,4MB);n*2MB, >=4MB
    - 染色指针: 提出指针的高四位,来存储四个标志信息,那么就只剩下42位可以用来寻址也就导致ZGC管理的内存不能超过4TB(2^42)  
    
        - Region中的某一个存活的对象被移走后能得到及时的释放和重用  
        - 大幅减少内存屏障的使用数量,目前只使用了读屏障  
        - 便于后续进一步提升性能,因为Linux目前占了寻址的前16位,如果把这16位开放了,就能不用挤占正式寻址的位置  

- 过程: 并发标记,并发预备重分配,并发重分配,并发重映射
